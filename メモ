import streamlit as st
import random

# å˜èªãƒªã‚¹ãƒˆ
words = [
    'admit', 'adventure', 'afford', 'appreciate', 'medicine', 'population', 'rely', 'conversation',
    'exactly', 'spirit', 'treat', 'anxious', 'unless', 'frankly', 'whisper', 'appointment',
    'decoration', 'decrease', 'despite', 'explanation', 'explorer', 'furniture', 'further',
    'charity', 'spare', 'forecast', 'audience', 'impress', 'apply', 'instruction', 'award',
    'destroy', 'generally', 'contain', 'sweep', 'ideal', 'chew', 'modern', 'author', 'nation',
    'ceremony', 'direction', 'issue', 'silly', 'eventually', 'ancestor', 'memorize', 'corporation',
    'product', 'citizen', 'prove', 'commercial', 'disappoint', 'journey', 'originally', 'soil',
    'fantastic', 'attractive', 'prevent', 'examination', 'role', 'courage', 'silence', 'confident',
    'emotion', 'nod', 'recommend', 'surround', 'hire', 'chemistry', 'require', 'forgive', 'stare',
    'exhibit', 'suggestion', 'constant', 'exhibition', 'operation', 'receipt', 'survive', 'otherwise',
    'suitable', 'avenue', 'earn', 'enemy', 'achieve', 'advertisement', 'instrument', 'organize',
    'unfortunately', 'describe', 'employ', 'examine', 'harmful', 'importance', 'region', 'relation',
    'rough', 'remind', 'surface'
]

# å˜èªè¾æ›¸
dictionary = set([
    'ad', 'it', 'admit', 'venture', 'afford', 'appreciate', 'med', 'medicine', 'pop', 'population',
    'rely', 'con', 'conversation', 'exact', 'exactly', 'spirit', 'treat', 'anxious', 'unless',
    'frank', 'frankly', 'whisper', 'appointment', 'decoration', 'decrease', 'despite',
    'explain', 'explanation', 'explore', 'explorer', 'furnish', 'furniture', 'further',
    'charity', 'spare', 'forecast', 'audience', 'impress', 'apply', 'instruct', 'instruction',
    'award', 'destroy', 'generally', 'contain', 'sweep', 'ideal', 'chew', 'modern', 'author',
    'nation', 'ceremony', 'direction', 'issue', 'silly', 'event', 'eventually', 'ancestor',
    'memorize', 'corporation', 'product', 'citizen', 'prove', 'commercial', 'disappoint',
    'journey', 'original', 'originally', 'soil', 'fantastic', 'attractive', 'prevent',
    'examination', 'role', 'courage', 'silence', 'confident', 'emotion', 'nod', 'recommend',
    'surround', 'hire', 'chemistry', 'require', 'forgive', 'stare', 'exhibit', 'suggestion',
    'constant', 'exhibition', 'operation', 'receipt', 'survive', 'otherwise', 'suitable',
    'avenue', 'earn', 'enemy', 'achieve', 'advertisement', 'instrument', 'organize',
    'unfortunately', 'describe', 'employ', 'examine', 'harmful', 'importance', 'region',
    'relation', 'rough', 'remind', 'surface', 'am', 'me', 'in', 'on', 'no', 'or', 'an'
])

# ãƒ¬ãƒ™ãƒ«ç®¡ç†
words_per_level = 3
if 'level' not in st.session_state:
    st.session_state.level = 0
if 'score' not in st.session_state:
    st.session_state.score = 0
if 'found_words' not in st.session_state:
    st.session_state.found_words = []
if 'current_selection' not in st.session_state:
    st.session_state.current_selection = []

# ç¾åœ¨ã®å˜èªã‚»ãƒƒãƒˆ
word_list = words[st.session_state.level * words_per_level:(st.session_state.level + 1) * words_per_level]
letters = list(set(''.join(word_list)))

# ã‚¿ã‚¤ãƒˆãƒ«ã¨æƒ…å ±è¡¨ç¤º
st.title("Word Connect")
st.write(f"ãƒ¬ãƒ™ãƒ«: {st.session_state.level + 1}")
st.write(f"ã‚¹ã‚³ã‚¢: {st.session_state.score}")

# CSS: ä¸¸ã„ãƒœã‚¿ãƒ³ã‚¹ã‚¿ã‚¤ãƒ«
st.markdown("""
    <style>
    div.stButton > button {
        border-radius: 50%;
        height: 60px;
        width: 60px;
        margin: 4px;
        font-weight: bold;
        font-size: 20px;
        background-color: #f2f2f2;
        color: #333;
        border: 2px solid #999;
        transition: all 0.2s ease-in-out;
    }
    div.stButton > button:hover {
        background-color: #ddd;
        border-color: #666;
    }
    </style>
""", unsafe_allow_html=True)

# ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
st.write("## ä½¿ãˆã‚‹æ–‡å­—")
cols = st.columns(len(letters))
for i, letter in enumerate(letters):
    if cols[i].button(letter, key=f"letter_{i}"):
        st.session_state.current_selection.append(letter)

# é¸æŠä¸­ã®å˜èªè¡¨ç¤º
current_word = ''.join(st.session_state.current_selection)
st.write(f"### é¸æŠä¸­ã®å˜èª: **{current_word}**")

# å˜èªãŒä½œã‚Œã‚‹ã‹ã®åˆ¤å®šé–¢æ•°
def can_form_word(word, letters_available):
    letters_copy = list(letters_available)
    for c in word:
        if c in letters_copy:
            letters_copy.remove(c)
        else:
            return False
    return True

# æå‡ºå‡¦ç†
if st.button("æå‡º"):
    if current_word in dictionary and can_form_word(current_word, letters) and current_word not in st.session_state.found_words:
        st.success(f"æ­£è§£ï¼ã€{current_word}ã€ã‚’è¦‹ã¤ã‘ã¾ã—ãŸã€‚")
        st.session_state.found_words.append(current_word)
        st.session_state.score += 1
    else:
        st.error("ä¸æ­£è§£ã‹æ—¢ã«è¦‹ã¤ã‘ãŸå˜èªã§ã™ã€‚")
    st.session_state.current_selection = []

# ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³
if st.button("reset"):
    st.session_state.current_selection = []

# ç™ºè¦‹æ¸ˆã¿å˜èª
st.write("## Myè¾æ›¸")
if st.session_state.found_words:
    st.write(", ".join(st.session_state.found_words))
else:
    st.write("ã¾ã å˜èªã¯è¦‹ã¤ã‹ã£ã¦ã„ã¾ã›ã‚“ã€‚")

# ãƒ¬ãƒ™ãƒ«ã‚¯ãƒªã‚¢åˆ¤å®š
required_words_found = all(word in st.session_state.found_words for word in word_list)
if required_words_found:
    st.success("ğŸ‰ ãƒ¬ãƒ™ãƒ«ã‚¯ãƒªã‚¢ï¼æ¬¡ã®ãƒ¬ãƒ™ãƒ«ã¸é€²ã¿ã¾ã™ã€‚")
    if st.button("æ¬¡ã®ãƒ¬ãƒ™ãƒ«ã¸"):
        st.session_state.level += 1
        st.session_state.found_words = []
        st.session_state.current_selection = []
        st.experimental_rerun()

# å…¨ãƒ¬ãƒ™ãƒ«çµ‚äº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
if st.session_state.level >= len(words) // words_per_level:
    st.balloons()
    st.write("ã™ã¹ã¦ã®ãƒ¬ãƒ™ãƒ«ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸï¼ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼")


    import streamlit as st
import random
import math
import streamlit.components.v1 as components

# åˆæœŸåŒ–
if 'current_selection' not in st.session_state:
    st.session_state.current_selection = []

# ãƒ©ãƒ³ãƒ€ãƒ ãª12æ–‡å­—
all_letters = list("ABCDEFGHIJKLMNOPQRSTUVWXYZ")
random.seed(0)
letters = random.sample(all_letters, 12)

# å††å½¢ã«ä¸¦ã¹ã‚‹ãƒœã‚¿ãƒ³ã®HTMLã‚’ç”Ÿæˆ
button_html = ''.join([
    f'''
    <button class="circle-button" id="button_{i}"
            data-letter="{letter}"
            style="left: {150 + 120 * math.cos(2 * math.pi * i / 12 - math.pi/2) - 30}px;
                   top:  {150 + 120 * math.sin(2 * math.pi * i / 12 - math.pi/2) - 30}px;">
        {letter}
    </button>
    ''' for i, letter in enumerate(letters)
])

# HTML + CSS + JavaScript ã‚’çµ„ã¿ç«‹ã¦
full_html = f"""
<html>
<head>
    <style>
    body {{
        margin: 0;
        font-family: Arial, sans-serif;
        user-select: none;
    }}
    .circle-container {{
        position: relative;
        width: 300px;
        height: 300px;
        margin: 60px auto 40px auto;
        border: 2px solid #ccc;
        border-radius: 50%;
    }}
    .circle-button {{
        position: absolute;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background-color: white;
        color: black;
        font-size: 20px;
        font-weight: bold;
        border: 2px solid #4CAF50;
        cursor: pointer;
        display: flex;
        justify-content: center;
        align-items: center;
        transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
    }}
    .circle-button.selected {{
        background-color: #FF5722;
        border-color: #FF5722;
        color: white;
    }}
    .circle-button:hover {{
        background-color: #f0f0f0;
    }}
    #selected-word {{
        width: 100%;
        text-align: center;
        font-size: 28px;
        font-weight: bold;
        padding-top: 10px;
        user-select: none;
        letter-spacing: 4px;
        min-height: 40px;
        color: #FF5722;
    }}
    canvas {{
        position: absolute;
        top: 60px;
        left: 40px;
        z-index: -1;
    }}
    </style>
</head>
<body>
<div id="selected-word"></div>

<div class="circle-container" id="circle-container">
    {button_html}
</div>

<canvas id="lineCanvas" width="300" height="300"></canvas>

<script>
    let isMouseDown = false;
    let selectedLetters = [];
    let points = [];

    const selectedWordDiv = document.getElementById('selected-word');

    function updateSelectedWord() {{
        selectedWordDiv.textContent = selectedLetters.join('');
    }}

    document.querySelectorAll('.circle-button').forEach(button => {{
        button.addEventListener('mousedown', function(event) {{
            isMouseDown = true;
            if (!event.target.classList.contains('selected')) {{
                event.target.classList.add('selected');
                selectedLetters.push(event.target.dataset.letter);
                points.push({{ x: event.target.offsetLeft + 30, y: event.target.offsetTop + 30 }});
                drawLine();
                updateSelectedWord();
            }}
            event.preventDefault();
        }});

        button.addEventListener('mouseenter', function(event) {{
            if (isMouseDown) {{
                if (!event.target.classList.contains('selected')) {{
                    event.target.classList.add('selected');
                    selectedLetters.push(event.target.dataset.letter);
                    points.push({{ x: event.target.offsetLeft + 30, y: event.target.offsetTop + 30 }});
                    drawLine();
                    updateSelectedWord();
                }}
            }}
        }});

        button.addEventListener('mouseup', function(event) {{
            isMouseDown = false;
            const queryString = selectedLetters.join(',');
            window.parent.postMessage({{type: 'letters', data: queryString}}, '*');
        }});
    }});

    function drawLine() {{
        const canvas = document.getElementById('lineCanvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if(points.length === 0) return;

        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        points.forEach(point => {{
            ctx.lineTo(point.x, point.y);
        }});
        ctx.strokeStyle = '#FF5722';
        ctx.lineWidth = 3;
        ctx.stroke();
    }}

    // ç”»é¢å…¨ä½“ã§ãƒã‚¦ã‚¹ã‚¢ãƒƒãƒ—ç›£è¦–
    document.addEventListener('mouseup', function() {{
        if(isMouseDown) {{
            isMouseDown = false;
            const queryString = selectedLetters.join(',');
            window.parent.postMessage({{type: 'letters', data: queryString}}, '*');
        }}
    }});
</script>
</body>
</html>
"""

st.title("Word Connect")
st.write("ãƒã‚¦ã‚¹ã‚’æŠ¼ã—ãªãŒã‚‰ãƒ‰ãƒ©ãƒƒã‚°ã™ã‚‹ã¨ãƒœã‚¿ãƒ³ãŒé †ã«é¸ã°ã‚Œã¾ã™ã€‚")

components.html(full_html, height=450)




import streamlit as st
import pandas as pd
import math
import streamlit.components.v1 as components

# Excelãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å•é¡Œã‚’èª­ã¿è¾¼ã‚€é–¢æ•°
@st.cache_data
def load_problems_from_excel(file_path):
    """Excelãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å•é¡Œã‚’èª­ã¿è¾¼ã‚€"""
    try:
        df = pd.read_excel(file_path)
        problems = {}
        
        # å„è¡Œã‚’å‡¦ç†ã—ã¦å•é¡Œã‚’ä½œæˆ
        for index, row in df.iterrows():
            stage_num = index + 1
            problem_text = str(row.iloc[0]).strip()  # æœ€åˆã®åˆ—ã‚’å•é¡Œæ–‡ã¨ã—ã¦ä½¿ç”¨
            
            # å•é¡Œæ–‡ã‹ã‚‰æ–‡å­—ã‚’æŠ½å‡ºï¼ˆé‡è¤‡ã‚’é™¤å»ï¼‰
            unique_letters = list(set(problem_text.upper().replace(' ', '')))
            
            # 2åˆ—ç›®ä»¥é™ã‹ã‚‰å˜èªã‚’æŠ½å‡º
            words = []
            for col_idx in range(1, len(row)):
                if pd.notna(row.iloc[col_idx]):
                    word = str(row.iloc[col_idx]).strip().upper()
                    if word and word not in words:
                        words.append(word)
            
            problems[stage_num] = {
                'name': f'ã‚¹ãƒ†ãƒ¼ã‚¸ {stage_num}',
                'problem_text': problem_text,
                'letters': unique_letters,
                'words': words
            }
        
        return problems
    except Exception as e:
        st.error(f"Excelãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
        return None

# ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å•é¡Œï¼ˆExcelãƒ•ã‚¡ã‚¤ãƒ«ãŒèª­ã¿è¾¼ã‚ãªã„å ´åˆã®å‚™ãˆï¼‰
DEFAULT_STAGES = {
    1: {
        'name': 'ã‚¹ãƒ†ãƒ¼ã‚¸ 1',
        'problem_text': 'CATDOG',
        'letters': ['C', 'A', 'T', 'D', 'O', 'G'],
        'words': ['CAT', 'DOG', 'COD', 'TAG', 'GOD', 'COG']
    },
    2: {
        'name': 'ã‚¹ãƒ†ãƒ¼ã‚¸ 2', 
        'problem_text': 'REDBLUE',
        'letters': ['R', 'E', 'D', 'B', 'L', 'U'],
        'words': ['RED', 'BLUE', 'BED', 'LED', 'RUB', 'BUG']
    },
    3: {
        'name': 'ã‚¹ãƒ†ãƒ¼ã‚¸ 3',
        'problem_text': 'BREADCAKE',
        'letters': ['B', 'R', 'E', 'A', 'D', 'C', 'K'],
        'words': ['BREAD', 'CAKE', 'DEAR', 'CARE', 'BEAR']
    }
}

# åˆæœŸåŒ–
if 'current_stage' not in st.session_state:
    st.session_state.current_stage = 1
if 'found_words' not in st.session_state:
    st.session_state.found_words = []
if 'stages' not in st.session_state:
    st.session_state.stages = None

# Excelãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å•é¡Œã‚’èª­ã¿è¾¼ã¿
if st.session_state.stages is None:
    try:
        loaded_stages = load_problems_from_excel('problems.xlsx')
        if loaded_stages:
            st.session_state.stages = loaded_stages
            st.success(f"âœ… Excelãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰{len(loaded_stages)}å€‹ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ")
        else:
            st.session_state.stages = DEFAULT_STAGES
            st.warning("âš ï¸ Excelãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ãƒ†ãƒ¼ã‚¸ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚")
    except:
        st.session_state.stages = DEFAULT_STAGES
        st.warning("âš ï¸ problems.xlsxãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ãƒ†ãƒ¼ã‚¸ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚")

STAGES = st.session_state.stages

# ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½
st.sidebar.header("ğŸ“ å•é¡Œãƒ•ã‚¡ã‚¤ãƒ«ã®ç®¡ç†")

uploaded_file = st.sidebar.file_uploader(
    "æ–°ã—ã„å•é¡Œãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰", 
    type=['xlsx', 'xls'],
    help="1åˆ—ç›®: å•é¡Œæ–‡ã€2åˆ—ç›®ä»¥é™: æ­£ç­”å˜èªã®Excelãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„"
)

if uploaded_file is not None:
    try:
        # ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å•é¡Œã‚’èª­ã¿è¾¼ã¿
        df = pd.read_excel(uploaded_file)
        
        # ãƒ‡ãƒ¼ã‚¿ã®ç¢ºèª
        st.sidebar.write("ğŸ“‹ ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹:")
        st.sidebar.dataframe(df.head())
        
        if st.sidebar.button("ã“ã®å•é¡Œãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½¿ç”¨"):
            new_stages = {}
            for index, row in df.iterrows():
                stage_num = index + 1
                problem_text = str(row.iloc[0]).strip()
                
                # å•é¡Œæ–‡ã‹ã‚‰æ–‡å­—ã‚’æŠ½å‡º
                unique_letters = list(set(problem_text.upper().replace(' ', '')))
                
                # å›ç­”åˆ—ã‹ã‚‰å˜èªã‚’æŠ½å‡º
                words = []
                for col_idx in range(1, len(row)):
                    if pd.notna(row.iloc[col_idx]):
                        word = str(row.iloc[col_idx]).strip().upper()
                        if word and word not in words:
                            words.append(word)
                
                new_stages[stage_num] = {
                    'name': f'ã‚¹ãƒ†ãƒ¼ã‚¸ {stage_num}',
                    'problem_text': problem_text,
                    'letters': unique_letters,
                    'words': words
                }
            
            st.session_state.stages = new_stages
            st.session_state.current_stage = 1
            st.session_state.found_words = []
            st.sidebar.success(f"ğŸ‰ æ–°ã—ã„å•é¡Œãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰{len(new_stages)}å€‹ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸï¼")
            st.rerun()
    
    except Exception as e:
        st.sidebar.error(f"âŒ ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")

# ç¾åœ¨ã®å•é¡Œãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±
st.sidebar.write(f"ğŸ“Š ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¸æ•°: {len(STAGES)}")
if st.sidebar.button("ğŸ”„ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ãƒ†ãƒ¼ã‚¸ã«æˆ»ã™"):
    st.session_state.stages = DEFAULT_STAGES
    st.session_state.current_stage = 1
    st.session_state.found_words = []
    st.rerun()

# ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ç”»é¢
st.title("ğŸ¯ Word Connect")

# ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¸æƒ…å ±ã‚’å–å¾—
if st.session_state.current_stage in STAGES:
    current_stage_info = STAGES[st.session_state.current_stage]
else:
    st.session_state.current_stage = 1
    current_stage_info = STAGES[1]

st.header(f"ğŸ® {current_stage_info['name']}")

# å•é¡Œæ–‡ã®è¡¨ç¤º
st.info(f"ğŸ’¡ å•é¡Œæ–‡: {current_stage_info['problem_text']}")

# ã‚¹ãƒ†ãƒ¼ã‚¸é¸æŠ
st.subheader("ğŸ“‹ ã‚¹ãƒ†ãƒ¼ã‚¸é¸æŠ")
stage_cols = st.columns(min(5, len(STAGES)))  # æœ€å¤§5åˆ—ã§è¡¨ç¤º

for i, stage_num in enumerate(list(STAGES.keys())[:5]):  # æœ€åˆã®5ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’è¡¨ç¤º
    col_idx = i % 5
    with stage_cols[col_idx]:
        stage_info = STAGES[stage_num]
        button_text = f"ã‚¹ãƒ†ãƒ¼ã‚¸ {stage_num}\n({len(stage_info['words'])}å˜èª)"
        if st.button(button_text, key=f"stage_{stage_num}"):
            st.session_state.current_stage = stage_num
            st.session_state.found_words = []
            st.rerun()

# è¿½åŠ ã®ã‚¹ãƒ†ãƒ¼ã‚¸ãŒã‚ã‚‹å ´åˆ
if len(STAGES) > 5:
    st.write("...")
    selected_stage = st.selectbox(
        "ä»–ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’é¸æŠ:",
        options=list(STAGES.keys()),
        index=st.session_state.current_stage - 1,
        format_func=lambda x: f"ã‚¹ãƒ†ãƒ¼ã‚¸ {x} ({len(STAGES[x]['words'])}å˜èª)"
    )
    if selected_stage != st.session_state.current_stage:
        st.session_state.current_stage = selected_stage
        st.session_state.found_words = []
        st.rerun()

# ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³
if st.button("ğŸ”„ ãƒªã‚»ãƒƒãƒˆ"):
    st.session_state.found_words = []
    st.rerun()

# é€²è¡ŒçŠ¶æ³
target_words = current_stage_info['words']
found_words = st.session_state.found_words
progress = len(found_words) / len(target_words) if target_words else 0
st.progress(progress)
st.write(f"ğŸ“ˆ é€²è¡ŒçŠ¶æ³: {len(found_words)} / {len(target_words)} å˜èª")

# ç›®æ¨™å˜èªè¡¨ç¤º
st.subheader("ğŸ¯ ç›®æ¨™å˜èª")
cols = st.columns(3)
for i, word in enumerate(target_words):
    col_idx = i % 3
    with cols[col_idx]:
        status = "âœ…" if word in found_words else "â¬œ"
        st.write(f"{status} {word}")

# è¦‹ã¤ã‘ãŸå˜èªè¡¨ç¤º
if found_words:
    st.success(f"ğŸ‰ è¦‹ã¤ã‘ãŸå˜èª: {', '.join(found_words)}")

# ã‚²ãƒ¼ãƒ ç”»é¢
letters = current_stage_info['letters']
num_letters = len(letters)

# å††å½¢ãƒœã‚¿ãƒ³ã®HTMLç”Ÿæˆ
button_html = ''.join([
    f'''
    <div class="circle-button" 
         data-letter="{letter}"
         data-index="{i}"
         style="left: {150 + 120 * math.cos(2 * math.pi * i / num_letters - math.pi/2) - 25}px;
                top:  {150 + 120 * math.sin(2 * math.pi * i / num_letters - math.pi/2) - 25}px;">
        {letter}
    </div>
    ''' for i, letter in enumerate(letters)
])

# JavaScriptãƒ‡ãƒ¼ã‚¿
js_target_words = str(target_words).replace("'", '"')
js_found_words = str(found_words).replace("'", '"')

html_content = f"""
<!DOCTYPE html>
<html>
<head>
    <style>
    body {{
        margin: 0;
        font-family: Arial, sans-serif;
        user-select: none;
        background: #f5f5f5;
    }}
    .circle-container {{
        position: relative;
        width: 300px;
        height: 300px;
        margin: 20px auto;
        border: 2px solid #333;
        border-radius: 50%;
        background: white;
    }}
    .circle-button {{
        position: absolute;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background: white;
        color: #333;
        font-size: 18px;
        font-weight: bold;
        border: 2px solid #333;
        cursor: pointer;
        display: flex;
        justify-content: center;
        align-items: center;
        transition: all 0.2s ease;
    }}
    .circle-button.selected {{
        background: #333;
        color: white;
    }}
    .circle-button:hover {{
        background: #eee;
    }}
    #selected-word {{
        text-align: center;
        font-size: 24px;
        font-weight: bold;
        padding: 20px;
        color: #333;
        min-height: 30px;
    }}
    canvas {{
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
    }}
    .message {{
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #4CAF50;
        color: white;
        padding: 20px;
        border-radius: 10px;
        font-size: 18px;
        font-weight: bold;
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.3s ease;
    }}
    .message.show {{
        opacity: 1;
    }}
    .wrong-message {{
        background: #f44336;
    }}
    </style>
</head>
<body>
    <div id="selected-word">æ–‡å­—ã‚’ç¹‹ã’ã¦å˜èªã‚’ä½œã£ã¦ãã ã•ã„</div>
    <div id="message" class="message">æ­£è§£ï¼</div>
    <div id="wrong-message" class="message wrong-message">ä¸æ­£è§£</div>
    
    <div class="circle-container" id="circle-container">
        {button_html}
        <canvas id="lineCanvas" width="300" height="300"></canvas>
    </div>

    <script>
        let isDragging = false;
        let selectedLetters = [];
        let selectedButtons = [];
        let points = [];
        let targetWords = {js_target_words};
        let foundWords = {js_found_words};

        const selectedWordDiv = document.getElementById('selected-word');
        const messageDiv = document.getElementById('message');
        const wrongMessageDiv = document.getElementById('wrong-message');
        const container = document.getElementById('circle-container');
        const canvas = document.getElementById('lineCanvas');
        const ctx = canvas.getContext('2d');

        function updateSelectedWord() {{
            selectedWordDiv.textContent = selectedLetters.length > 0 ? 
                selectedLetters.join('') : 'æ–‡å­—ã‚’ç¹‹ã’ã¦å˜èªã‚’ä½œã£ã¦ãã ã•ã„';
        }}

        function checkCorrectWord() {{
            const currentWord = selectedLetters.join('').toUpperCase();
            if (currentWord.length === 0) return false;
            
            if (targetWords.includes(currentWord) && !foundWords.includes(currentWord)) {{
                foundWords.push(currentWord);
                showMessage(true);
                
                // Streamlitã«é€šçŸ¥
                setTimeout(() => {{
                    window.parent.postMessage({{
                        type: 'streamlit:setComponentValue',
                        value: currentWord
                    }}, '*');
                }}, 500);
                
                return true;
            }} else if (currentWord.length > 0) {{
                showMessage(false);
                return false;
            }}
            return false;
        }}

        function showMessage(isCorrect) {{
            const msgDiv = isCorrect ? messageDiv : wrongMessageDiv;
            msgDiv.classList.add('show');
            setTimeout(() => {{
                msgDiv.classList.remove('show');
            }}, 1500);
        }}

        function getButtonCenterPosition(button) {{
            const rect = button.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();
            return {{
                x: rect.left - containerRect.left + rect.width / 2,
                y: rect.top - containerRect.top + rect.height / 2
            }};
        }}

        function resetSelection() {{
            selectedLetters = [];
            selectedButtons = [];
            points = [];
            document.querySelectorAll('.circle-button').forEach(button => {{
                button.classList.remove('selected');
            }});
            updateSelectedWord();
            drawLine();
        }}

        function selectButton(button) {{
            if (!selectedButtons.includes(button)) {{
                button.classList.add('selected');
                selectedLetters.push(button.dataset.letter);
                selectedButtons.push(button);
                points.push(getButtonCenterPosition(button));
                updateSelectedWord();
                drawLine();
            }}
        }}

        function getButtonAtPosition(x, y) {{
            const buttons = document.querySelectorAll('.circle-button');
            const containerRect = container.getBoundingClientRect();
            
            for (let button of buttons) {{
                const buttonLeft = parseFloat(button.style.left);
                const buttonTop = parseFloat(button.style.top);
                const relativeX = x - containerRect.left;
                const relativeY = y - containerRect.top;
                
                if (relativeX >= buttonLeft && relativeX <= buttonLeft + 50 &&
                    relativeY >= buttonTop && relativeY <= buttonTop + 50) {{
                    return button;
                }}
            }}
            return null;
        }}

        function drawLine() {{
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (points.length > 1) {{
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {{
                    ctx.lineTo(points[i].x, points[i].y);
                }}
                ctx.stroke();
            }}
        }}

        // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
        container.addEventListener('mousedown', (e) => {{
            const button = getButtonAtPosition(e.clientX, e.clientY);
            if (button) {{
                isDragging = true;
                resetSelection();
                selectButton(button);
            }}
        }});

        container.addEventListener('mousemove', (e) => {{
            if (isDragging) {{
                const button = getButtonAtPosition(e.clientX, e.clientY);
                if (button && !selectedButtons.includes(button)) {{
                    selectButton(button);
                }}
            }}
        }});

        container.addEventListener('mouseup', () => {{
            if (isDragging) {{
                isDragging = false;
                if (selectedLetters.length > 0) {{
                    const found = checkCorrectWord();
                    setTimeout(resetSelection, found ? 500 : 1000);
                }}
            }}
        }});

        // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆ
        container.addEventListener('touchstart', (e) => {{
            e.preventDefault();
            const touch = e.touches[0];
            const button = getButtonAtPosition(touch.clientX, touch.clientY);
            if (button) {{
                isDragging = true;
                resetSelection();
                selectButton(button);
            }}
        }});

        container.addEventListener('touchmove', (e) => {{
            e.preventDefault();
            if (isDragging) {{
                const touch = e.touches[0];
                const button = getButtonAtPosition(touch.clientX, touch.clientY);
                if (button && !selectedButtons.includes(button)) {{
                    selectButton(button);
                }}
            }}
        }});

        container.addEventListener('touchend', (e) => {{
            e.preventDefault();
            if (isDragging) {{
                isDragging = false;
                if (selectedLetters.length > 0) {{
                    const found = checkCorrectWord();
                    setTimeout(resetSelection, found ? 500 : 1000);
                }}
            }}
        }});

        // åˆæœŸåŒ–
        updateSelectedWord();
    </script>
</body>
</html>
"""

# HTMLã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’è¡¨ç¤º
found_word = components.html(html_content, height=400, scrolling=False)

# å˜èªãŒè¦‹ã¤ã‹ã£ãŸå ´åˆã®å‡¦ç†
if found_word and found_word not in st.session_state.found_words:
    st.session_state.found_words.append(found_word)
    st.rerun()

# ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¯ãƒªã‚¢åˆ¤å®š
if len(st.session_state.found_words) == len(target_words):
    st.balloons()
    st.success("ğŸ‰ ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¯ãƒªã‚¢ï¼ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼")
    
    # æ¬¡ã®ã‚¹ãƒ†ãƒ¼ã‚¸ãŒã‚ã‚‹å ´åˆ
    next_stage = st.session_state.current_stage + 1
    if next_stage in STAGES:
        if st.button(f"ğŸš€ æ¬¡ã®ã‚¹ãƒ†ãƒ¼ã‚¸ ({next_stage}) ã¸é€²ã‚€"):
            st.session_state.current_stage = next_stage
            st.session_state.found_words = []
            st.rerun()